export {};

declare const args: any[];

alert(...args);
alert(...args);
alert.apply(alert, args);
alert.apply(null, ...[args] as const);
alert.apply(...[null, args] as const);

declare const fn: ((...args: any[]) => void) | undefined;
fn!(...args);
fn?.(...args);
(fn as (...args: any[]) => void)(...args);

declare const obj: {apply(a: any, b: any): any};
obj.apply(null, args);

const nested = {obj};
nested.obj.apply(nested, args);

console.log.apply(null, args);
console.log(...args);
console.log.apply(console.log, args);
console.log.apply(obj, args);
console['log'](...args);
(console['log'])!(...args);
window.console.log(...args);
window.console.log(...args);
window.console.log(...args);
window['console'].log(...args);
window['console'].log(...args);

declare let objArr: {fn: (...args: any[]) => void}[];
declare let i: number;
objArr[0].fn(...args);
objArr[0].fn(...args);
objArr[0].fn.apply(objArr[1], args);
objArr[i].fn(...args);
objArr[objArr.length].fn(...args);
objArr[objArr.length].fn(...args);
objArr[objArr.length - 1].fn.apply(objArr[objArr.length - 1], args);

objArr[Symbol.iterator](...args);

class C {
    #fn!: (...args: any[]) => void;
    #obj: {fn: (...args: any[]) => void};
    [key: string]: {fn: (...args: any[]) => void};
    constructor() {
        this.#fn(...args);
        this.#fn.apply(new C(), args);
        this.#fn.apply(null, args);
        this.#obj.fn(...args);
        this.#obj.fn.apply(this, args);

        this.#obj.fn.apply(this['#obj'], args);
        this.#obj.fn.apply(this['obj'], args);
        this['#obj'].fn.apply(this.#obj, args);
        this['#obj'].fn(...args);
    }
}

class Base {
    fn(...args: any[]) {};
}

class Derived extends Base {
    fn() {
        super.fn(...args);
    }
}

fn(...args);
fn(...args);

fn(...args);

fn.apply //
